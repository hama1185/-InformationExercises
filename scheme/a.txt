(問題1)
出力結果として
status = 0
status = 256
status = 512
status = 768
status = 1024
status = 1280
status = 1536
status = 1792
status = 2048
status = 2304
が得られる.
この結果は9行目のif(fork()==0)で一度だけ子プロセスがforkによって
生成され10行目のexit(i)で一度目の処理だったためi=0なので子プロセスは
0を返す.12行目にてwait(&status)があるため子プロセスの終了まで待ち,子プロセスが
返した0を受け取り,statusには256とiの積が渡されるため.
(問題2)
(1)
他のディレクトリのiノード番号が参照できると
各ディレクトリの階層から他の階層のディレクトリにアクセスできるようになる機能が
実現できるため.また/tmpがdir2を作成するときdir2では自身を指すハードリンクが作成されるため同じiノードが
他の階層に生成される.
(2)
ln zzz.c zzzz.cを実行
/tmp/dir2にiノード番号が15,zzzz.cという名前の
ファイルが生成される.
cp zzz.c zzzzz.c
/tmp/dir2にiノード番号が割り振られていない新規の番号30として
zzzzz.cという名前のファイルが生成される.
(問題3)
(1)
OSのカーネルにおいて対応するプロセスの状態を表すデータ構造でOSによっては
保護された便利な配置としてプロセス毎のカーネルスタックの先頭部分に置かれる.
内容としてはPCBをつなぐポインタやプロセスid,利用者領域へのポインタなどが入る.
(2)
ページの置き換えのためのアルゴリズムの1つで
最も長い期間使用されていないページを選択する.
長所として頻繁にアクセスするページはページアウトされないことや
Beladyの異常が起きないことが挙げられる.また短所として各ページの
参照時刻の記録が必要でありハードウェアの支援が必要である.
(3)
仮想アドレスと実アドレスの対応付けを適当な大きさのブロック単位で行うもの
(4)
参照の偏りであり,最近参照されたデータは近い将来も参照される可能性
が高いという時間的局所性と参照されたデータの近傍のデータは参照される
可能性が高い空間的局所性にわかれる.
(5)
タイマモジュールによって定期的に発生するハードウェア的割り込み

(問題4)
5行目をiの繰り返し
6行目をkの繰り返し
7行目をjの繰り返しとすると効率がよいと考える

同じ行の要素が連続してメモリ上に配置されるためなるべく
同じ行の要素に続けてアクセスした方が使用するメモリアドレスも連続になるため
空間の局所性より動作が効率よくなる.8行目の計算に着目するとjは行でのアクセスが2つ,
kは行へのアクセスが1つ,列へのアクセスが1つ,iは列へのアクセスが2つである.そのため
上記の通りにすることで順番が反転することがなく連続的にアクセスされるため動作が効率よくなる.
(問題5)
(1)
到着順
実行順はABCDの順である.
平均レスポンス時間 60秒((0+10+90+140)/4)
平均ターンアラウンド時間　115秒((20+110+160+170)/4)

処理時間順
実行順はABDCの順である.
平均レスポンス時間 50秒((0+10+70+120)/4)
平均ターンアラウンド時間 105秒((20+110+100+190)/4)

ラウンドロビン
実行順はABCBDCBDCBCBの順である.
平均レスポンス時間 12.5秒((0+10+10+30)/4)
平均ターンアラウンド時間 125秒((20+210+170+100)/4)

(2)
順に論ずる
到着時間
Bのような処理時間の長いジョブが最初に到着すると平均ターンアラウンド時間が大きくなってしまい
プロセスに割り当てられる時間が不公平になってしまう.また性能がよいとは言い難い.
処理時間
到着順ではABCDの順であったが短いプロセスが先に実行されるためABDCとなり
平均レスポンス時間は到着順より短く優位性が見られた.しかし処理時間が既知でないと実現できないため
到着順と比較し実装が困難である.
ラウンドロビン
他の2種類と比較すると平均レスポンス時間が短く優位性が見られた.
CPU横取りありの結果であるため妥当である.またタイムスライスを短くすると
コンテキストのオーバーヘッドが大きくなってしまう.